# @nestjs-ssr/react

React SSR for NestJS. Controllers return data. Components render it.

## Installation

```bash
npx @nestjs-ssr/react init
```

Creates entry points, registers RenderModule, updates tsconfig for JSX.

## Architecture

Screaming architecture: views live next to their controllers. Each NestJS module owns its UI.

```
src/
├── products/
│   ├── products.controller.ts    # @Render(ProductList)
│   ├── products.service.ts
│   ├── products.module.ts
│   └── views/
│       ├── product-list.tsx      # Component
│       └── product-detail.tsx
├── users/
│   ├── users.controller.ts
│   └── views/
│       └── user-profile.tsx
└── views/
    ├── entry-client.tsx          # Hydration entry (global)
    ├── entry-server.tsx          # SSR entry (global)
    ├── index.html                # HTML template
    └── layout.tsx                # Root layout (auto-discovered)
```

Controllers import components directly. Type mismatch = build fails.

## @Render Decorator

```typescript
@Get(':id')
@Render(ProductDetail)
async getProduct(@Param('id') id: string) {
  const product = await this.productService.findById(id);
  return { product };
}
```

Return value becomes `data` prop in component.

**With options:**

```typescript
@Render(ProductDetail, {
  layout: ProductLayout,
  layoutProps: { showSidebar: true },
  head: { title: 'Product' }
})
```

| Option        | Type            | Description       |
| ------------- | --------------- | ----------------- |
| `layout`      | `ComponentType` | Layout override   |
| `layoutProps` | `object`        | Static props      |
| `head`        | `HeadData`      | Static head tags  |

**Skip layouts:**

```typescript
@Render(Modal, { layout: false })  // Skip controller layout only
@Render(Modal, { layout: null })   // Skip ALL layouts including root
```

## @Layout Decorator

Controller-level layout for all routes:

```typescript
@Controller('admin')
@Layout(AdminLayout, { props: { sidebar: true } })
export class AdminController {
  @Get()
  @Render(Dashboard)
  getDashboard() { return { stats: {} }; }
}
```

## PageProps Interface

```typescript
interface PageProps<T> {
  data: T;
}

export default function ProductDetail({ data }: PageProps<{ product: Product }>) {
  return <h1>{data.product.name}</h1>;
}
```

## HeadData (SEO)

Return `head` from controller for dynamic SEO:

```typescript
return {
  product,
  head: {
    title: product.name,
    description: product.description,
    keywords: 'product, shop',
    canonical: `https://example.com/products/${product.id}`,

    // Open Graph
    ogTitle: product.name,
    ogDescription: product.description,
    ogImage: product.imageUrl,

    // Additional meta tags
    meta: [
      { name: 'author', content: 'John Doe' },
      { property: 'og:type', content: 'product' }
    ],

    // Link tags (fonts, icons, preloads)
    links: [
      { rel: 'icon', href: '/favicon.ico' },
      { rel: 'preload', href: '/font.woff2', as: 'font', type: 'font/woff2' }
    ],

    // Scripts (analytics, tracking)
    scripts: [
      { src: '/analytics.js', async: true },
      { innerHTML: 'console.log("inline")', type: 'text/javascript' }
    ],

    // JSON-LD structured data
    jsonLd: [
      { '@type': 'Product', name: product.name, price: product.price }
    ],

    // HTML/body attributes
    htmlAttributes: { lang: 'en', dir: 'ltr' },
    bodyAttributes: { class: 'dark-mode' }
  }
};
```

Static head in decorator, dynamic head in return value. Return value wins on conflict.

## Layouts

Three levels. More specific wins.

1. **Root layout** — `views/layout.tsx` (auto-discovered)
2. **Controller layout** — `@Layout(AdminLayout)`
3. **Method layout** — `@Render(Page, { layout: SettingsLayout })`

Nesting order: root → controller → method → page.

```tsx
// views/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}
```

Layout components receive `layoutProps` from decorators and return values.

## SSR Modes

| Mode   | Method                   | Use Case                     |
| ------ | ------------------------ | ---------------------------- |
| string | `renderToString`         | Default. Atomic. Simple.     |
| stream | `renderToPipeableStream` | Better TTFB. Suspense.       |

```typescript
RenderModule.forRoot({ mode: 'stream' });
```

**Trade-offs:**

- String: Complete HTML or error. Proper status codes.
- Stream: Faster first byte. Errors after shell = HTTP 200 with partial content.

## Client-Side Hooks

```typescript
import {
  useParams,
  useQuery,
  useHeaders,
  useSession,
  useRequest,
  usePageContext
} from '@nestjs-ssr/react/client';
```

| Hook             | Returns                            |
| ---------------- | ---------------------------------- |
| `useParams<T>()` | Route parameters `{ id: '123' }`   |
| `useQuery<T>()`  | Query string `{ page: '1' }`       |
| `useHeaders()`   | Whitelisted headers                |
| `useSession<T>()`| Whitelisted session                |
| `useRequest()`   | `{ url, method, params, query }`   |
| `usePageContext()`| Full context object               |

**Whitelist headers/session in config:**

```typescript
RenderModule.forRoot({
  allowedHeaders: ['accept-language', 'x-tenant-id'],
  allowedCookies: ['theme', 'locale']
});
```

Everything else stays server-side.

## Client-Side Navigation

Segment rendering: only fetch changed portion of page. No full reloads.

**Link component:**

```tsx
import { Link } from '@nestjs-ssr/react/client';

<Link href="/products">Products</Link>
<Link href="/about" replace>About</Link>
<Link href="/settings" scroll={false}>Settings</Link>
```

| Prop      | Type    | Default | Description                     |
| --------- | ------- | ------- | ------------------------------- |
| `href`    | string  | —       | Target URL                      |
| `replace` | boolean | false   | replaceState vs pushState       |
| `scroll`  | boolean | true    | Scroll to top after navigation  |

**Programmatic navigation:**

```typescript
import { navigate } from '@nestjs-ssr/react/client';

await navigate('/dashboard');
await navigate('/settings', { replace: true, scroll: false });
```

**Navigation state:**

```tsx
import { useNavigationState } from '@nestjs-ssr/react/client';

function Nav() {
  const state = useNavigationState(); // 'idle' | 'loading'
  return state === 'loading' ? <Spinner /> : null;
}
```

**How it works:**

1. Click Link or call navigate()
2. Client reads `data-layout` attributes from DOM
3. Fetch with `X-Current-Layouts` header
4. Server returns JSON: `{ html, swapTarget, props }`
5. Swap content in matching `data-outlet`
6. Hydrate new segment
7. Update history and head tags

Falls back to full navigation when layouts don't match.

## RenderModule Configuration

```typescript
RenderModule.forRoot({
  mode: 'string',                              // 'string' | 'stream'
  vite: { port: 5173 },                        // Vite dev server port
  allowedHeaders: ['accept-language'],         // Exposed to client
  allowedCookies: ['theme'],                   // Exposed to client
  defaultHead: { title: 'My App' }             // Default SEO
});
```

**Async config:**

```typescript
RenderModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  useFactory: (config) => ({
    mode: config.get('SSR_MODE')
  })
});
```

## HTML Template

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!--head-meta-->
    <!--styles-->
  </head>
  <body>
    <div id="root"><!--app-html--></div>
    <!--initial-state-->
    <!--client-scripts-->
  </body>
</html>
```

Placeholders filled by renderer.

## Exports

```typescript
// Server: @nestjs-ssr/react
import {
  RenderModule,
  Render,
  Layout,
  PageProps,
  HeadData,
  RenderContext
} from '@nestjs-ssr/react';

// Client: @nestjs-ssr/react/client
import {
  useParams,
  useQuery,
  useHeaders,
  useSession,
  useRequest,
  usePageContext,
  Link,
  navigate,
  useNavigationState,
  PageContextProvider
} from '@nestjs-ssr/react/client';
```

## Testing

Controllers and components test independently:

```typescript
// Controller test - no React
const result = await controller.getProduct('123');
expect(result).toEqual({ product: { id: '123', name: 'Widget' } });

// Component test - no NestJS
render(<ProductDetail data={{ product: mockProduct }} />);
expect(screen.getByText('Widget')).toBeInTheDocument();
```

## Development

```bash
pnpm start:dev    # Vite + NestJS concurrently
```

Vite on 5173, NestJS on 3000. HMR works. Component changes hot-reload.

## Production

```bash
pnpm build        # nest build && vite build
pnpm start:prod
```

Build order matters: NestJS first (clears dist), then Vite bundles.
