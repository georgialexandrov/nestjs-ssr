# Getting Started with @nestjs-ssr/react

A step-by-step guide to add React SSR to your NestJS application.

## Prerequisites

- Node.js 18 or later
- Basic knowledge of NestJS and React
- A NestJS project (or create one with `nest new my-app`)

## Installation

```bash
# Using npm
npm install @nestjs-ssr/react react react-dom vite @vitejs/plugin-react

# Using pnpm
pnpm add @nestjs-ssr/react react react-dom vite @vitejs/plugin-react

# Using yarn
yarn add @nestjs-ssr/react react react-dom vite @vitejs/plugin-react
```

## Step-by-Step Setup

### Step 1: Configure Vite

Create `vite.config.ts` in your project root:

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { viewRegistryPlugin } from '@nestjs-ssr/react/vite';

export default defineConfig({
  plugins: [
    react(),
    viewRegistryPlugin(), // Auto-discovers your views
  ],
  server: {
    port: 5173,
  },
});
```

**What this does:**
- `react()` - Enables React fast refresh and JSX transformation
- `viewRegistryPlugin()` - Automatically scans and registers your view components

### Step 2: Import RenderModule in Your App Module

Update your `app.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { RenderModule } from '@nestjs-ssr/react';
import { AppController } from './app.controller';

@Module({
  imports: [
    RenderModule.register(), // âœ¨ That's it!
  ],
  controllers: [AppController],
})
export class AppModule {}
```

**Optional configuration:**

```typescript
RenderModule.register({
  mode: 'stream',  // Use streaming SSR (faster TTFB)
  errorPageDevelopment: CustomErrorPage,  // Custom error page
})
```

### Step 3: Create Your First View

Create `src/views/home.tsx`:

```typescript
import type { PageProps } from '@nestjs-ssr/react';

interface HomeData {
  title: string;
  message: string;
}

export default function Home({ data, context }: PageProps<HomeData>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <title>{data.title}</title>
      </head>
      <body>
        <div id="root">
          <h1>{data.message}</h1>
          <p>Requested from: {context.path}</p>
        </div>
      </body>
    </html>
  );
}
```

**Best practices:**
- Always use `PageProps<T>` for type safety
- The `data` prop contains data from your controller
- The `context` prop contains request information

### Step 4: Create a Controller

Update `src/app.controller.ts`:

```typescript
import { Controller, Get } from '@nestjs/common';
import { Render } from '@nestjs-ssr/react';

@Controller()
export class AppController {
  @Get()
  @Render('views/home')
  getHome() {
    return {
      title: 'Welcome',
      message: 'Hello from NestJS SSR!',
    };
  }
}
```

**How it works:**
1. The `@Render('views/home')` decorator specifies which view to render
2. The return value becomes the `data` prop in your component
3. NestJS renders the React component on the server
4. HTML is sent to the browser

### Step 5: Add React Entry Files

Create the directory structure:

```bash
mkdir -p src/view
```

Create `src/view/entry-client.tsx`:

```typescript
import { hydrateRoot } from 'react-dom/client';
import { AppWrapper } from '@nestjs-ssr/react';
import { viewRegistry } from './view-registry.generated';

const rootElement = document.getElementById('root');

if (!rootElement) {
  throw new Error('Root element not found');
}

hydrateRoot(
  rootElement,
  <AppWrapper
    viewRegistry={viewRegistry}
    initialProps={window.__INITIAL_PROPS__}
    initialContext={window.__RENDER_CONTEXT__}
  />
);

// Clean up global variables
delete window.__INITIAL_PROPS__;
delete window.__RENDER_CONTEXT__;
```

Create `src/view/entry-server.tsx`:

```typescript
import { AppWrapper } from '@nestjs-ssr/react';
import { viewRegistry } from './view-registry.generated';

export function render(viewPath: string, props: any, context: any) {
  return (
    <AppWrapper
      viewRegistry={viewRegistry}
      viewPath={viewPath}
      initialProps={props}
      initialContext={context}
    />
  );
}
```

Create `src/view/view-registry.generated.ts` (initial version):

```typescript
// This file will be auto-generated by the Vite plugin
import type React from 'react';

export const viewRegistry: Record<string, React.ComponentType<any>> = {};
```

### Step 6: Update package.json Scripts

Add these scripts to your `package.json`:

```json
{
  "scripts": {
    "dev": "concurrently \"npm:dev:vite\" \"npm:dev:nest\"",
    "dev:vite": "vite",
    "dev:nest": "nest start --watch",
    "build": "npm run build:client && npm run build:server && nest build",
    "build:client": "vite build --outDir dist/client",
    "build:server": "vite build --ssr src/view/entry-server.tsx --outDir dist/server",
    "start": "node dist/main"
  }
}
```

Install `concurrently` if you haven't:

```bash
npm install -D concurrently
```

### Step 7: Run Your App

```bash
npm run dev
```

Visit [http://localhost:3000](http://localhost:3000)

You should see your server-rendered React app! ðŸŽ‰

## What Just Happened?

1. **Vite Development Server** runs on port 5173, handling HMR for React components
2. **NestJS Server** runs on port 3000, handling HTTP requests and SSR
3. **View Registry Plugin** automatically discovers components in `src/**/views/*.tsx`
4. **When a request hits `/`:**
   - NestJS controller returns data
   - `@Render` decorator intercepts the response
   - React component is rendered to HTML on the server
   - HTML is sent to the browser with hydration data
   - Client-side React "hydrates" the server HTML
   - App is now fully interactive!

## Next Steps

### Add More Views

Create more views in `src/views/` or in module-specific folders like `src/users/views/`:

```typescript
// src/users/views/user-profile.tsx
export default function UserProfile({ data }: PageProps<{ user: User }>) {
  return <div>{data.user.name}</div>;
}
```

```typescript
// src/users/users.controller.ts
@Get(':id')
@Render('users/views/user-profile')
async getUser(@Param('id') id: string) {
  const user = await this.usersService.findOne(id);
  return { user };
}
```

### Use React Hooks

Access request context in any component:

```typescript
import { usePageContext, useParams } from '@nestjs-ssr/react';

function UserComponent() {
  const context = usePageContext();
  const params = useParams();

  return <div>User {params.id} from {context.path}</div>;
}
```

### Add Shared Components

Create reusable components in `src/shared/views/`:

```typescript
// src/shared/views/layout.tsx
export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <title>My App</title>
      </head>
      <body>
        <nav>Navigation</nav>
        <main>{children}</main>
      </body>
    </html>
  );
}
```

Use it in your views:

```typescript
import { Layout } from '@shared/views/layout';

export default function Home({ data }: PageProps<HomeData>) {
  return (
    <Layout>
      <h1>{data.message}</h1>
    </Layout>
  );
}
```

### Add Client-Side Interactivity

```typescript
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

This works seamlessly with SSR - the initial HTML is server-rendered, then React hydrates and makes it interactive.

### Enable Streaming SSR

For faster time-to-first-byte:

```typescript
RenderModule.register({
  mode: 'stream',
})
```

Streaming sends HTML progressively as it's rendered, improving perceived performance.

### Add Error Monitoring

```typescript
import { MonitoringModule, ConsoleErrorReporter } from '@nestjs-ssr/react';

@Module({
  imports: [
    MonitoringModule.forRoot({
      errorReporter: new ConsoleErrorReporter(),
    }),
    RenderModule.register(),
  ],
})
```

Or integrate with Sentry, Datadog, etc.

## Troubleshooting

### Views Not Found

- Ensure views are in `src/**/views/*.tsx`
- Check that `viewRegistryPlugin()` is in your `vite.config.ts`
- Restart the dev server

### Hydration Mismatches

- Ensure server and client render the same HTML
- Avoid using `Date.now()` or random values during SSR
- Use `useEffect` for client-only logic

### HMR Not Working

- Ensure Vite dev server is running on port 5173
- Check that `@vitejs/plugin-react` is installed
- Clear browser cache

### Import Errors

- Use `@nestjs-ssr/react` (not relative imports to `node_modules`)
- Ensure all peer dependencies are installed
- Check TypeScript configuration

## Examples

- **[Minimal Example](../examples/minimal/)** - Start here
- **[Full-Featured Example](../examples/full-featured/)** - Real-world patterns

## Further Reading

- [Why NestJS SSR?](./why-nestjs-ssr.md)
- [Architecture Overview](./ARCHITECTURE.md)
- [Testing Guide](./TESTING_STRATEGY.md)
- [Production Deployment](./PRODUCTION_RISKS.md)

---

**Questions?** [Open an issue](https://github.com/yourusername/nestjs-ssr/issues) or check the [examples](../examples/).
