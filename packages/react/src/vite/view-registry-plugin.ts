import { Plugin } from 'vite';
import { glob } from 'glob';
import path from 'path';
import fs from 'fs';

/**
 * Vite plugin that auto-generates a view registry from all view files.
 * Scans for view files matching the pattern and creates a registry mapping paths to components.
 *
 * This eliminates the need to manually maintain view registries in entry-server.tsx and entry-client.tsx.
 */
export function viewRegistryPlugin(): Plugin {
  const REGISTRY_FILE = path.resolve(process.cwd(), 'src/view/view-registry.generated.ts');
  const ENTRY_CLIENT_FILE = path.resolve(process.cwd(), 'src/view/entry-client.tsx');
  const ENTRY_SERVER_FILE = path.resolve(process.cwd(), 'src/view/entry-server.tsx');
  const SRC_DIR = path.resolve(process.cwd(), 'src');

  /**
   * Ensure entry files exist by creating them from templates if missing.
   */
  function ensureEntryFiles() {
    const viewDir = path.dirname(REGISTRY_FILE);

    // Ensure src/view directory exists
    if (!fs.existsSync(viewDir)) {
      fs.mkdirSync(viewDir, { recursive: true });
    }

    // Locate template files from the package
    // When installed: node_modules/@nestjs-ssr/react/dist/vite/ -> ../../src/templates
    const templateDir = path.resolve(__dirname, '../../src/templates');
    const entryClientTemplatePath = path.join(templateDir, 'entry-client.tsx');
    const entryServerTemplatePath = path.join(templateDir, 'entry-server.tsx');

    // Create entry-client.tsx if it doesn't exist
    if (!fs.existsSync(ENTRY_CLIENT_FILE)) {
      if (fs.existsSync(entryClientTemplatePath)) {
        const template = fs.readFileSync(entryClientTemplatePath, 'utf-8');
        fs.writeFileSync(ENTRY_CLIENT_FILE, template, 'utf-8');
        console.log('[view-registry] ✓ Created entry-client.tsx');
      } else {
        console.warn('[view-registry] Template not found:', entryClientTemplatePath);
      }
    }

    // Create entry-server.tsx if it doesn't exist
    if (!fs.existsSync(ENTRY_SERVER_FILE)) {
      if (fs.existsSync(entryServerTemplatePath)) {
        const template = fs.readFileSync(entryServerTemplatePath, 'utf-8');
        fs.writeFileSync(ENTRY_SERVER_FILE, template, 'utf-8');
        console.log('[view-registry] ✓ Created entry-server.tsx');
      } else {
        console.warn('[view-registry] Template not found:', entryServerTemplatePath);
      }
    }
  }

  /**
   * Generate the view registry file by scanning for view components.
   */
  async function generateRegistry() {
    try {
      // Find all view files in src/**/views/*.tsx
      // Exclude shared/views/* (those are components, not page views)
      const viewFiles = await glob('**/views/*.tsx', {
        cwd: SRC_DIR,
        absolute: false,
        ignore: ['shared/views/**'],
      });

      if (viewFiles.length === 0) {
        console.warn('[view-registry] No view files found in src/**/views/*.tsx');
        return;
      }

      // Generate imports and registry entries
      const imports: string[] = [];
      const registryEntries: string[] = [];

      viewFiles.forEach((file: string) => {
        // Convert file path to component name
        // e.g., "app/views/home.tsx" -> "AppViewsHome"
        // Replace hyphens with underscores first, then convert to PascalCase
        const componentName = file
          .replace(/\.tsx$/, '')
          .replace(/-/g, '_') // Convert hyphens to underscores
          .replace(/\//g, '_')
          .split('_')
          .map((part: string) => part.charAt(0).toUpperCase() + part.slice(1))
          .join('');

        // Create import path relative to src/view/
        // e.g., "../app/views/home"
        const importPath = `../${file.replace(/\.tsx$/, '')}`;

        // Create registry key (remove .tsx extension)
        // e.g., "app/views/home"
        const registryKey = file.replace(/\.tsx$/, '');

        imports.push(`import ${componentName} from '${importPath}';`);
        registryEntries.push(`  '${registryKey}': ${componentName},`);
      });

      // Generate list of view paths for type augmentation
      const viewPaths = viewFiles.map((file: string) => `  '${file.replace(/\.tsx$/, '')}': true;`);

      // Generate the TypeScript file
      const registryContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the view-registry-plugin.
 * Any manual changes will be overwritten.
 *
 * To add a new view, simply create a .tsx file in any module's views/ directory.
 * The view will be automatically registered and available for use.
 */

import React from 'react';

${imports.join('\n')}

/**
 * View registry mapping paths to React components.
 * This is auto-generated from all files matching the pattern.
 */
export const viewRegistry: Record<string, React.ComponentType<any>> = {
${registryEntries.join('\n')}
};

/**
 * Type-safe view path - union of all registered view paths.
 * Use this with ReactRender decorator for IDE autocomplete and validation.
 */
export type ViewPath = keyof typeof viewRegistry;

/**
 * Get all registered view paths.
 */
export function getRegisteredViews(): string[] {
  return Object.keys(viewRegistry);
}

/**
 * Check if a view path is registered.
 */
export function isViewRegistered(path: string): boolean {
  return path in viewRegistry;
}

/**
 * Module augmentation for @nestjs-ssr/react
 * Provides type safety for ReactRender decorator
 */
declare module '@nestjs-ssr/react' {
  interface ViewPaths {
${viewPaths.join('\n')}
  }
}
`;

      // Write the generated file
      fs.writeFileSync(REGISTRY_FILE, registryContent, 'utf-8');

      const count = viewFiles.length;
      console.log(`[view-registry] Generated registry with ${count} view${count === 1 ? '' : 's'}`);
    } catch (error) {
      console.error('[view-registry] Failed to generate registry:', error);
      throw error;
    }
  }

  return {
    name: 'view-registry',

    // Generate registry on startup
    // Skip in SSR middleware mode to prevent regeneration on NestJS restarts
    async buildStart() {
      // Only regenerate if not in SSR middleware mode (used by NestJS)
      if (process.env.VITE_MIDDLEWARE !== 'true') {
        ensureEntryFiles();
        await generateRegistry();
      }
    },

    // Watch for changes to view files
    configureServer(server) {
      // Skip watcher setup in SSR middleware mode
      if (process.env.VITE_MIDDLEWARE === 'true') {
        return;
      }

      const watcher = server.watcher;

      // Watch for view file changes
      watcher.on('add', async (file) => {
        if (file.includes('/views/') && file.endsWith('.tsx')) {
          console.log(`[view-registry] New view detected: ${path.relative(process.cwd(), file)}`);
          await generateRegistry();

          // Trigger HMR for the registry file
          const module = server.moduleGraph.getModuleById(REGISTRY_FILE);
          if (module) {
            server.moduleGraph.invalidateModule(module);
            server.ws.send({
              type: 'full-reload',
              path: '*',
            });
          }
        }
      });

      watcher.on('unlink', async (file) => {
        if (file.includes('/views/') && file.endsWith('.tsx')) {
          console.log(`[view-registry] View removed: ${path.relative(process.cwd(), file)}`);
          await generateRegistry();

          // Trigger HMR for the registry file
          const module = server.moduleGraph.getModuleById(REGISTRY_FILE);
          if (module) {
            server.moduleGraph.invalidateModule(module);
            server.ws.send({
              type: 'full-reload',
              path: '*',
            });
          }
        }
      });
    },

    // Regenerate on build
    async buildEnd() {
      await generateRegistry();
    },
  };
}
